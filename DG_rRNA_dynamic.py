"""
minjiezhang123@gmail.com    2020-12-16      python 3

"""


#1. input and output setup
################################################################################
################################################################################
#this section sets up the input and output
import sys, argparse, numpy, os, re, itertools, random, math, pysam, RNA
from datetime import datetime
from sklearn.metrics import roc_curve, auc
import matplotlib as mpl  
import matplotlib.pyplot as plt
from math import floor, ceil
from itertools import product
from Bio.PDB.PDBParser import PDBParser
import seaborn as sns
from collections import Counter

if len(sys.argv) < 3:
    print("Usage:           python DG_rRNA_dynamic.py  sam_crssant  bp_arc_file  dsRNA.bedpe  expansion_segment.bed  4v6x.cif/4v6x_distance.txt  DG_reads_cutoff  distance_cutoff  DGcommon_ratio  winbin  DG/reads  outputprefix")
    print("sam_crssant:     sam file generated by crssant.py")
    print("bp_arc_file:     base pair information generated from PDB file")
    print("                 can use PDB2arc.py generate this arc file")
    print("dsRNAbedpe:      dsRNA information in bedpe format. eg: hs45_dsRNA.bedpe")
    print("expansion_segment.bed:   ")
    print("                 bed file of expansion segment information")
    print("PDBfile:         PDB file downloaed from PDB database")
    print("4v6x_distance.txt:   matrix_PDB_distance.txt generated from 4v6x")
    print("DG_reads_cutoff: minimum reads number of each DG")
    print("distance_cutoff: minimum distance was considered as tertiary structure, otherwise was considered as inter-molecular interactions")
    print("DGcommon_ratio:  minimum ratio to call the common region of each DG")
    print("winbin:          window bins")
    print("outputprefix                                     ")
    sys.exit()

inputsam = open(sys.argv[1],'r')
arcfile = open(sys.argv[2],'r')
dsRNAbedpe = open(sys.argv[3],'r')
expansion_segment_bed = open(sys.argv[4],'r')
PDBfile = sys.argv[5]
minreads = int(sys.argv[6])
mindistance = int(sys.argv[7])
DGcommoncutoff = float(sys.argv[8])
winbin = int(sys.argv[9])
DGorReads = sys.argv[10]
outprefix = sys.argv[11]

################################################################################


#2. subfunctions
################################################################################
def timenow(): return str(datetime.now())[:-7]

def mergeCIGAR(CIGAR): 
    #merge all operations that consume the reference, i.e. MI=X
    #example: 1S2M3N4M5I6M7S -> 1S2M3N10M7S 
    ops = re.findall('\d+[MNISH=X]', CIGAR) #all that consume query
    newops = [ops[0]]
    for op in ops[1:]: #concatenate all internal ops that consume query [MIS=X
        if op[-1] not in "I=X":
            if newops[-1][-1]=="M" and op[-1]=="M":
                newops[-1] = str(int(newops[-1][:-1])+int(op[:-1]))+"M"
            else: newops.append(op)
    newCIGAR = ("".join(str(i) for i in newops))
    return newCIGAR


def getsegs(line, segs): #turn an alignment into segs [(RNAME, STRAND L, R), ...]
    align = line.split()
    RNAME, POS, CIGAR = align[2], int(align[3]), align[5]
    STRAND = '-' if '{0:012b}'.format(int(align[1]))[-5] == '1' else '+'
    if align[0] not in segs: segs[align[0]] = [] #store all gaps from this CIGAR string, each as a 3-tuple.
    seglens = [int(i[:-1]) for i in re.findall('[0-9]+M', mergeCIGAR(CIGAR))] #seg lengths
    Ns =[i.rstrip('0123456789') for i in mergeCIGAR(CIGAR).split('M')]
    rx = [] #reference consumed: MD=X
    for N in Ns:
        rx.append(sum([int(i[:-1]) for i in re.findall('[0-9]+[ND=X]', N)]))
    for i in range(len(seglens)): #combine ref and segment lengths to make the junctions
        l, r = POS+sum(rx[:i+1])+sum(seglens[:i]), POS+sum(rx[:i+1])+sum(seglens[:i+1])-1
        if (RNAME, int(l), int(r), STRAND) not in segs[align[0]]: segs[align[0]].append((RNAME, int(l), int(r), STRAND))
        segs[align[0]].sort()
    #print(segs[align[0]])
    if len(segs[align[0]]) == 2: return segs[align[0]]
    
    
def normdist(list1,list2):
    mu1=np.mean(list1); sigma1 =np.std(list1)
    mu2=np.mean(list2); sigma2 =np.std(list2)
    overlap = NormalDist(mu1, sigma1).overlap(NormalDist(mu2, sigma2))
    return overlap


def getDGspan(DGspan):
    #DGspan['12S,12S,0']=[[('hs12S','2','22','+'),('hs12S','270','295','+')], [('hs12S','3','24','+'),('hs12S','285','300','+')]]
    #DGspan['12S,12S,1']=[[('hs12S', 8, 20, '+'), ('hs12S', 108, 137, '+')], [('hs12S', 6, 24, '+'), ('hs12S', 106, 145, '+')]]
    for DG in DGspan:
        DGslist=DGspan[DG]
        #print(DG)
        #print(DGspan[DG][0],DGspan[DG][-1])
        segls, segle, segrs, segre = int(DGslist[0][0][1]), int(DGslist[0][0][2]), int(DGslist[0][1][1]), int(DGslist[0][1][2])
        for i in range(1,len(DGslist),1):
            if int(DGslist[i][0][1]) < segls: segls=int(DGslist[i][0][1])
            if int(DGslist[i][0][2]) > segle: segle=int(DGslist[i][0][2])
            if int(DGslist[i][1][1]) < segrs: segrs=int(DGslist[i][1][1])
            if int(DGslist[i][1][2]) > segre: segre=int(DGslist[i][1][2])
        DGspan[DG]=[[DGslist[0][0][0],segls,segle,segle-segls+1],[DGslist[0][1][0],segrs,segre,segre-segrs+1]]
    return DGspan


def coveragenorm(dglist,dgspan,cutoff):
    #dglist: [[chr1,1,15,+],[chr1,31,45,+]], [[chr1,2,13,+],[chr1,33,43,+]], [[chr1,5,20,+],[chr1,40,50,+]]...
    #dgspan: [[chr1,1,25,25],[chr1,30,50,25]]]
    #cutoff: 0.8
    dgspannew=[]; count=-1
    for arm in dgspan:
        poscoverage = {};
        dgstart=0; dgend=0; count+=1
        for i in range(int(arm[1]),int(arm[2])+1,1): poscoverage[i] = 0 #initialize the pos coverage
        
        for seg in dglist:
            if getOverlap(arm, seg[count]) == "Ture":
                for i in range(int(seg[count][1]),int(seg[count][2])+1,1): poscoverage[i] += 1
        for i in range(int(arm[1]),int(arm[2])+1,1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgstart = i; break;
        for i in range(int(arm[2]),int(arm[1]),-1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgend = i; break;
        
        len = dgend - dgstart + 1
        dgspannew.append([arm[0],str(dgstart),str(dgend), seg[count][3]])
    return dgspannew
"""
dglist=[[['chr1',1,15,'+'],['chr1',31,45,'+']], [['chr1',2,13,'+'],['chr1',33,43,'+']], [['chr1',5,20,'+'],['chr1',40,50,'+']]]
dgspan=[['chr1','1','25','25'],['chr1','30','50','25']]
cutoff=0.6
print(coveragenorm(dglist,dgspan,cutoff))
output: [['chr1', '2', '15', '14', '+'], ['chr1', '33', '45', '11', '+']]
"""
"""
dglist=[[('hs45S', 11867, 11894, '+'), ('hs45S', 11965, 11990, '+')], [('hs45S', 11874, 11901, '+'), ('hs45S', 11961, 11973, '+')], [('hs45S', 11872, 11886, '+'), ('hs45S', 11977, 11991, '+')], [('hs45S', 11874, 11898, '+'), ('hs45S', 11954, 11972, '+')], [('hs45S', 11875, 11903, '+'), ('hs45S', 11952, 11970, '+')], [('hs45S', 11875, 11896, '+'), ('hs45S', 11965, 11986, '+')], [('hs45S', 11875, 11890, '+'), ('hs45S', 11967, 11985, '+')], [('hs45S', 11877, 11903, '+'), ('hs45S', 11948, 11967, '+')], [('hs45S', 11867, 11883, '+'), ('hs45S', 11976, 11991, '+')], [('hs45S', 11867, 11885, '+'), ('hs45S', 11973, 11990, '+')], [('hs45S', 11867, 11885, '+'), ('hs45S', 11972, 11990, '+')]]
dgspan=[['hs45S', 11832, 11925, 94], ['hs45S', 11927, 12039, 113]]
cutoff=0.8
print(dglist)
print(dgspan)
print(coveragenorm(dglist,dgspan,cutoff))
"""


#bed1 [chr,14,23] -> [3:11-15; 4:16-20; 5:21-25]
#bed2 [chr,23,45] -> [5:21-25; 6:26-30; 7:31-35; 8:36-40; 9:41-45]
#out: [(3, 6), (4, 7), (5, 8)]
def getPos(bed1, bed2, winbin,start):
    chr1, start1, end1 = bed1[0], int(bed1[1])-int(start)+1, int(bed1[2])-int(start)+1
    chr2, start2, end2 = bed2[0], int(bed2[1])-int(start)+1, int(bed2[2])-int(start)+1
    pos1 = []; pos2 = []; pos1new = []; pos2new = []
    for i in range(ceil(start1/winbin), ceil(end1/winbin)+1, 1):
        pos1.append(i)
    for i in range(ceil(start2/winbin), ceil(end2/winbin)+1, 1):
        pos2.append(i)
    if len(pos1) >= len(pos2):
        max = len(pos1); min = len(pos2)
        start = int((max-min)/2);   end = start + min
        pos1new = pos1[start:end];  pos2new = pos2
    else:
        max = len(pos2); min = len(pos1)
        start = int((max-min)/2);   end = start + min
        pos1new = pos1;  pos2new = pos2[start:end][::-1]
    return list(zip(pos1new, pos2new))


def DNA_complement1(sequence):
    comp_dict = {"A":"T","T":"A","G":"C","C":"G","a":"t","t":"a","g":"c","c":"g"}
    sequence_list = list(sequence)
    sequence_list = [comp_dict[base] for base in sequence_list]
    string = ''.join(sequence_list)
    return string


def getfa(bed,ref):
    #bed: [chr1,12,25,+]
    RNAME,fastart,faend,STRAND = bed[0], bed[1], bed[2], bed[3]
    faseq = ''
    if STRAND == '+': faseq = ref.fetch(RNAME, int(fastart)-1, int(faend))
    if STRAND == '-': faseq = (DNA_complement1(ref.fetch(RNAME, int(fastart)-1, int(faend))))[::-1]
    return faseq.replace("T", "U")


def getOverlap(a, b): 
    overlap = int(min(int(a[2]),int(b[2]))) - int(max(int(a[1]),int(b[1])))
    #readslen = (int(b[2]) - int(b[1]))/2
    if overlap >= 1: seganno = "Ture"
    else: seganno = "False"
    return seganno


# get dsRNA and nondsRNA DGs
def get_dsRNADGs(newDGspan, dsRNAinfo):
    DG_dsRNA = {};  DG_nondsRNA = {}
    # newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
    # dsRNAinfo:   [['hs45S', 12941, 12945, '+'], ['hs45S', 12952, 12956, '+']]
    for DG in newDGspan:
        dsRNA = 'False'
        for bp in dsRNAinfo:
            if getOverlap(newDGspan[DG][0], bp[0]) == "Ture" and getOverlap(newDGspan[DG][1], bp[1]) == "Ture":
                dsRNA = 'True'
                break
        if dsRNA == 'True': DG_dsRNA[DG] = newDGspan[DG]
        else:   DG_nondsRNA[DG] = newDGspan[DG]
    return DG_dsRNA,DG_nondsRNA

"""
def get_esDGs(DG_nondsRNA, ESinfo):
    # ESinfo: {ESL5: [hs45S,8038,8080,+]}
    DG_nondsRNA_ES = {};    # expansion segment DG
    DG_nondsRNA_CS = {};    # core segment DG
    for DG in DG_nondsRNA:
        ES = 'False'
        for es in ESinfo:
            if getOverlap(DG_nondsRNA[DG][0], ESinfo[es]) == "Ture" or getOverlap(DG_nondsRNA[DG][1], ESinfo[es]) == "Ture":
                ES = 'True'
                break
        if ES == 'True':    DG_nondsRNA_ES[DG] = DG_nondsRNA[DG]
        else:   DG_nondsRNA_CS[DG] = DG_nondsRNA[DG]
    return DG_nondsRNA_ES,DG_nondsRNA_CS
"""


def get_esDGs(bed, ESinfo):
    # ESinfo: {ESL5: [hs45S,8038,8080,+]}
    seganno = "core"
    for es in ESinfo:
        if getOverlap(bed, ESinfo[es]) == "Ture": seganno = "expansion"; continue;
    return seganno

        

## test whether bed1 was included by bed2:
def bedinregions(bed, regions):
    # bed = ['hs45S', '3998', '4012', '+']
    # regions = [['hs45S', '3654', '5523'], ['hs45S', '6600', '6757'], ['hs45S', '7924', '12994']]
    bedanno = 'False'
    for targetbed in regions:
        if str(bed[0]) == str(targetbed[0]):
            if int(bed[1]) >= int(targetbed[1]) and int(bed[2]) <= int(targetbed[2]):
                bedanno = 'True'
                #print(bedanno)
                continue
    return bedanno


## get newDGspan with two arms located in target regions:
# newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
def get_targetDG(newDGspan, targetregion):
    #targetregion: hs45S:3654:5523,hs45S:6600:6757,hs45S:7924:12994
    regions = []; newDGspan_filter = {}
    for i in targetregion.split(','): regions.append(i.split(':'))
    for DG in newDGspan:
        if bedinregions(newDGspan[DG][0], regions) == 'True' and bedinregions(newDGspan[DG][1], regions) == 'True':
            if DG not in newDGspan_filter: newDGspan_filter[DG] = []
            newDGspan_filter[DG] = newDGspan[DG]
    return newDGspan_filter
        
################################################################################



#3 start processing the sam file.
################################################################################
logfile = open(outprefix + 'log.out', 'w')
logstr = timenow()+" Started exo.py ...\n"
logstr += (timenow()+" Collecting alignments into a dictionary ...")
logfile.write(logstr+'\n');  print(logstr,)
dgdict = {}; #{sample-dgid: [(RNAME, str(ls), str(le), STRAND),(RNAME, str(rs), str(re), STRAND)] [] []..}
DGspan = {}; DGs=[];  segs={}; newDGspan = {}; newDGspan_filter = {}

if DGorReads == "DG":
    for line in inputsam:
        #build the dgdict: dictionary of all segment terminals
        #format: dgid:[RNAME, STRAND, lstart, lend, rstart rend]
        if line[0]=='@': continue
        align = line.split('\t')
        dgloc = len(align); dgid = None #check where the dgid is
        if align[dgloc-2][:2]=='DG': dgid = (align[dgloc-2].split(':')[-1])
        else: sys.exit("Error, DG ID not found in column 19")
        sample = align[0].split('-')[-1]
        if dgid not in DGs: DGs.append(dgid)
        dgid_sample = sample+'-'+dgid
        if dgid not in dgdict: dgdict[dgid]=[] #initialize the item
        if getsegs(line,segs):  dgdict[dgid].append(getsegs(line,segs))
        if dgid not in DGspan: DGspan[dgid]=[]
        if getsegs(line,segs):  DGspan[dgid].append(getsegs(line,segs))
    inputsam.close()

    ## get DGspan of raw data
    DGspan = getDGspan(DGspan)

    ## get the common region of each DG
    for DG in DGspan:
        if len(dgdict[DG]) >= minreads:  # filter DG based on DG_reads_cutoff parameter
            newDGspan[DG] = coveragenorm(dgdict[DG],DGspan[DG],DGcommoncutoff)


if DGorReads == "reads":
    for line in inputsam:
        #build the dgdict: dictionary of all segment terminals
        #format: dgid:[RNAME, STRAND, lstart, lend, rstart rend]
        if line[0]=='@': continue
        align = line.split('\t')
        readID = align[0]
        if readID not in newDGspan: newDGspan[readID] = []
        if getsegs(line,segs):  newDGspan[readID] = getsegs(line,segs)
    inputsam.close()


## filter newDGspan that located in targe regions:
#newDGspan_filter = get_targetDG(newDGspan, 'hs45S:3654:5523,hs45S:6600:6757,hs45S:7924:12994')
################################################################################



#4. Get base pairing and noBP information:
################################################################################
print(str(datetime.now())[:-7], "Get base pairing information ...")
DGsbp = {}; DGs3D = {}; DGsInter = {}
PDBntposdict = {}

################################################################################
## read dsRNA information (bp_acr_file)
print(str(datetime.now())[:-7], "Get bp_acr_file information ...")
bpinfo = {} #[[1HR2, 6, 112], [1HR2, 7, 111]...]
lines = arcfile.readlines()[1:] # remove header
for line in lines:
    #track graphType=arc
    #1HR2    6       112     stemloop1
    chr, start, end, stem = line.rstrip('\n').split('\t')
    #dsRNAinfo.append([chr,int(start),int(end)])
    bpinfo[int(start)] = 1
    bpinfo[int(end)] = 1
arcfile.close()
lines = []

for i in range(1, 13358, 1):
    if i not in bpinfo:
        bpinfo[i] = 0
        
        
## get noBP list of 18S 28S and 5.8S
noBPlist_18S = {};  noBPlist_28S = {}; noBPlist_58S = {}
for i in range(1, 12995, 1):
    if i >= 3654 and i <= 5523: noBPlist_18S[i] = bpinfo[i]
    if i >= 6600 and i <= 6757: noBPlist_58S[i] = bpinfo[i]
    if i >= 7924 and i <= 12994: noBPlist_28S[i] = bpinfo[i]
################################################################################


################################################################################
## read dsRNA bedpe information (hs45_dsRNA.bedpe)
print(str(datetime.now())[:-7], "Get dsRNA.bedpe information ...")
dsRNAinfo = []; dsRNAinfo_18S = []; dsRNAinfo_28S = []; dsRNAinfo_58S = []
for line in dsRNAbedpe:
    # dsRNAbedpe:  hs45S	3658	3661	+	hs45S	3671	3674	+
    chr, start, end, strand, chr2, start2, end2, strand2 = line.rstrip('\n').split('\t')
    if start <= start2:
        dsRNAinfo.append([[chr,int(start),int(end),strand], [chr2,int(start2),int(end2),strand2]])
    else:
        dsRNAinfo.append([[chr2,int(start2),int(end2),strand2], [chr,int(start),int(end),strand]])
dsRNAbedpe.close()
        
        
## get dsRNAinfo of 18S 28S and 5.8S
for i in dsRNAinfo:
    if i[0][1] >= 3654 and i[1][2] <= 5523: dsRNAinfo_18S.append(i)
    if i[0][1] >= 6600 and i[1][2] <= 6757: dsRNAinfo_58S.append(i)
    if i[0][1] >= 7924 and i[1][2] <= 12994: dsRNAinfo_28S.append(i)
################################################################################



################################################################################
## read expansion_segment bed information (hs45S_ES.bed)
print(str(datetime.now())[:-7], "Get expansion_segment information ...")
ESinfo = {}  # ESinfo: {ESL5: [hs45S,8038,8080,+]}
ESinfo_18S = {};       ESinfo_28S = {};    
for line in expansion_segment_bed:
    #hs45S	8038	8080	+	ESL5
    chr, start, end, strand, name = line.rstrip('\n').split('\t')
    ESinfo[name] = [chr, int(start), int(end), strand]
expansion_segment_bed.close()
    
# get expansion segment info of 18S and 28S:
for ES in ESinfo:
    if ESinfo[ES][1] >= 3654 and ESinfo[ES][2] <= 5523: ESinfo_18S[ES] = ESinfo[ES]
    if ESinfo[ES][1] >= 7924 and ESinfo[ES][2] <= 12994: ESinfo_28S[ES] = ESinfo[ES]
################################################################################





#5. Get distance information from PDB files:
################################################################################
## read PDB file and generate the distance matrix
print(str(datetime.now())[:-7], "Get distance information from PDB files ...")

if "cif" in PDBfile or "pdb" in PDBfile:
    numcol = 13357; numrow = 13357
    chainpos = {}
    for i in range(3655, 5525, 1):  chainpos[i] = ['B2', i-3654]
    for i in range(6601, 6759, 1):  chainpos[i] = ['A8', i-6600]
    for i in range(7925, 12996, 1): chainpos[i] = ['A5', i-7924]
    
    matrix_PDB_distance = numpy.zeros((13357,13357))

    from Bio.PDB import *
    parser = MMCIFParser()
    structure = parser.get_structure("Sample", PDBfile)
    group = "O2'"

    for i in chainpos:
        for j in chainpos:
            if chainpos[i][1] in structure[0][chainpos[i][0]] and chainpos[j][1] in structure[0][chainpos[j][0]]:
                if group in structure[0][chainpos[i][0]][chainpos[i][1]] and group in structure[0][chainpos[j][0]][chainpos[j][1]]:
                    matrix_PDB_distance[(i-1), (j-1)] = structure[0][chainpos[i][0]][chainpos[i][1]][group] - structure[0][chainpos[j][0]][chainpos[j][1]][group]
    # numpy.savetxt("matrix_PDB_distance.txt", matrix_PDB_distance, fmt="%s", delimiter=",")
    # matrix_PDB_distance = numpy.loadtxt("matrix_PDB_distance.txt",delimiter=",")


if "txt" in PDBfile:
    matrix_PDB_distance = numpy.loadtxt(PDBfile, delimiter=",")
################################################################################    



def get_esDGs(bed, ESinfo):
    # ESinfo: {ESL5: [hs45S,8038,8080,+]}
    seganno = "core"
    for es in ESinfo:
        if getOverlap(bed, ESinfo[es]) == "Ture": seganno = "expansion"; continue;
    return seganno

    
def get_5_6ssnt_distance_from_newDGspan(bedl, bedr, matrix_PDB_distance, noBPlist, start, end, regions, regione):
    # newDGspan: {'1HR2,1HR2,0': [['1HR2', '2', '8', '+'], ['1HR2', '10', '15', '+']]}
    # noBPlist = [2,3,4,7,8,9,11,12,13]
    left_arm_target = []; right_arm_target = [];  dislist = []
    # left arm
    for i in range(int(bedl[2])-regions+1, int(bedl[2])-regione, -1):
        if noBPlist[i] == 0: left_arm_target.append(i)
    # right arm
    for i in range(int(bedr[2])-regions+1, int(bedr[2])-regione, -1):
        if noBPlist[i] == 0: right_arm_target.append(i)
    if left_arm_target and right_arm_target:
        loop_val = [left_arm_target,right_arm_target]
        for i in product(*loop_val):
            if matrix_PDB_distance[(i[0]-1), (i[1]-1)] > 0: dislist = [i[0]-start+1, i[1]-start+1, matrix_PDB_distance[(i[0]-1), (i[1]-1)]]; break
        for i in product(*loop_val):
            if matrix_PDB_distance[(i[0]-1), (i[1]-1)] > 0 and matrix_PDB_distance[(i[0]-1), (i[1]-1)] < dislist[2]:
                dislist = [i[0]-start+1, i[1]-start+1, matrix_PDB_distance[(i[0]-1), (i[1]-1)]]
    if dislist: return dislist
    else: return ['NA', 'NA', 'NA']


def get_min_distance_pos_from_newDGspan(bedl, bedr, matrix_PDB_distance, noBPlist, start, end):
    dislist = []; leftlist = []; rightlist = []
    for i in range(int(bedl[1]), int(bedl[2])+1, 1):
        if noBPlist[i] == 0: leftlist.append(i)
    for j in range(int(bedr[1]), int(bedr[2])+1, 1):
        if noBPlist[j] == 0: rightlist.append(j)
    if leftlist and rightlist:
        loop_val = [leftlist,rightlist]
        for i in product(*loop_val):
            if matrix_PDB_distance[(i[0]-1), (i[1]-1)] > 0: dislist = [i[0]-start+1, i[1]-start+1, matrix_PDB_distance[(i[0]-1), (i[1]-1)]]; break
        for i in product(*loop_val):
            if matrix_PDB_distance[(i[0]-1), (i[1]-1)] > 0 and matrix_PDB_distance[(i[0]-1), (i[1]-1)] < dislist[2]:
                dislist = [i[0]-start+1, i[1]-start+1, matrix_PDB_distance[(i[0]-1), (i[1]-1)]]
    if dislist: return dislist
    else: return ['NA', 'NA', 'NA']



################################################################################
noBPdis_18S = {};  noBPdis_28S = {}; noBPdis_58S = {}

logfile = open(outprefix + 'log.out', 'w')
logstr = timenow()+" Started exo.py ...\n"
logstr += (timenow()+" Collecting alignments into a dictionary ...")
logfile.write(logstr+'\n');  print(logstr,)


## hs28S min distance
newDGspan_filter = {}; newDGspan_filter_dsRNA = {}; newDGspan_filter_nondsRNA={}; newDGspan_filter_ES={}; newDGspan_filter_CS={}
newDGspan_filter = get_targetDG(newDGspan, 'hs45S:7924:12994')
newDGspan_filter_dsRNA, newDGspan_filter_nondsRNA = get_dsRNADGs(newDGspan_filter, dsRNAinfo_28S)
#newDGspan_filter_ES, newDGspan_filter_CS = get_esDGs(newDGspan_filter_nondsRNA, ESinfo_28S)
logstr = ''
logstr += ("        DGs/reads number of 28S:" + '\n')
logstr += ("         total DGs/reads of 28S: " + str(len(newDGspan_filter)) +'\n')
logstr += ("         dsRNA DGs/reads of 28S: " + str(len(newDGspan_filter_dsRNA)) +'\n')
logstr += ("      nondsRNA DGs/reads of 28S: " + str(len(newDGspan_filter_nondsRNA)) +'\n')
logstr += ("               core segment DGs/reads of 28S: " + str(len(newDGspan_filter_CS)) +'\n')
logstr += ("          expansion segment DGs/reads of 28S: " + str(len(newDGspan_filter_ES)) +'\n')
logfile.write(logstr+'\n');  print(logstr,)

f = open(outprefix+'_28S_DG_distance.txt','w')
f.write('DG\treads#\tleft_arm\tright_arm\tleft_loc\tright_loc\tmin_L_pos\tmin_R_pos\tmin_distance\t5ssnt_L_pos\t5ssnt_R_pos\t5ssnt_distance\n')
for DG in newDGspan_filter_nondsRNA:
    dislist_min = get_min_distance_pos_from_newDGspan(newDGspan_filter_nondsRNA[DG][0], newDGspan_filter_nondsRNA[DG][1], matrix_PDB_distance, noBPlist_28S, 7924, 12994)
    dislist_5ssnt = get_5_6ssnt_distance_from_newDGspan(newDGspan_filter_nondsRNA[DG][0], newDGspan_filter_nondsRNA[DG][1], matrix_PDB_distance, noBPlist_28S, 7924, 12994, 3, 7)
    DG_left_start = str(int(newDGspan_filter_nondsRNA[DG][0][1])-7924+1)
    DG_left_end   = str(int(newDGspan_filter_nondsRNA[DG][0][2])-7924+1)
    DG_right_start = str(int(newDGspan_filter_nondsRNA[DG][1][1])-7924+1)
    DG_right_end   = str(int(newDGspan_filter_nondsRNA[DG][1][2])-7924+1)
    string = str(DG)+'\t'+str(len(dgdict[DG]))+'\t'+DG_left_start+'-'+DG_left_end+'\t'+DG_right_start+'-'+DG_right_end+'\t'+str(get_esDGs(newDGspan_filter_nondsRNA[DG][0], ESinfo))+'\t'+ \
    str(get_esDGs(newDGspan_filter_nondsRNA[DG][1], ESinfo))+'\t'+'\t'.join(str(i) for i in dislist_min)+'\t'+'\t'.join(str(i) for i in dislist_5ssnt)+'\n'
    f.write(string)
f.close()


## hs18S min distance
newDGspan_filter = {}; newDGspan_filter_dsRNA = {}; newDGspan_filter_nondsRNA={}; newDGspan_filter_ES={}; newDGspan_filter_CS={}
newDGspan_filter = get_targetDG(newDGspan, 'hs45S:3654:5523')
newDGspan_filter_dsRNA, newDGspan_filter_nondsRNA = get_dsRNADGs(newDGspan_filter, dsRNAinfo_18S)
#newDGspan_filter_ES, newDGspan_filter_CS = get_esDGs(newDGspan_filter_nondsRNA, ESinfo_28S)
logstr = ''
logstr += ("        DGs/reads number of 18S:" + '\n')
logstr += ("         total DGs/reads of 18S: " + str(len(newDGspan_filter)) +'\n')
logstr += ("         dsRNA DGs/reads of 18S: " + str(len(newDGspan_filter_dsRNA)) +'\n')
logstr += ("      nondsRNA DGs/reads of 18S: " + str(len(newDGspan_filter_nondsRNA)) +'\n')
logstr += ("               core segment DGs/reads of 18S: " + str(len(newDGspan_filter_CS)) +'\n')
logstr += ("          expansion segment DGs/reads of 18S: " + str(len(newDGspan_filter_ES)) +'\n')
logfile.write(logstr+'\n');  print(logstr,)

f = open(outprefix+'_18S_DG_distance.txt','w')
f.write('DG\treads#\tleft_arm\tright_arm\tleft_loc\tright_loc\tmin_L_pos\tmin_R_pos\tmin_distance\t5ssnt_L_pos\t5ssnt_R_pos\t5ssnt_distance\n')
for DG in newDGspan_filter_nondsRNA:
    dislist_min = get_min_distance_pos_from_newDGspan(newDGspan_filter_nondsRNA[DG][0], newDGspan_filter_nondsRNA[DG][1], matrix_PDB_distance, noBPlist_18S, 3654, 5523)
    dislist_5ssnt = get_5_6ssnt_distance_from_newDGspan(newDGspan_filter_nondsRNA[DG][0], newDGspan_filter_nondsRNA[DG][1], matrix_PDB_distance, noBPlist_18S, 3654, 5523, 3, 7)
    DG_left_start = str(int(newDGspan_filter_nondsRNA[DG][0][1])-3654+1)
    DG_left_end   = str(int(newDGspan_filter_nondsRNA[DG][0][2])-3654+1)
    DG_right_start = str(int(newDGspan_filter_nondsRNA[DG][1][1])-3654+1)
    DG_right_end   = str(int(newDGspan_filter_nondsRNA[DG][1][2])-3654+1)
    string = str(DG)+'\t'+str(len(dgdict[DG]))+'\t'+DG_left_start+'-'+DG_left_end+'\t'+DG_right_start+'-'+DG_right_end+'\t'+str(get_esDGs(newDGspan_filter_nondsRNA[DG][0], ESinfo))+'\t'+ \
    str(get_esDGs(newDGspan_filter_nondsRNA[DG][1], ESinfo))+'\t'+'\t'.join(str(i) for i in dislist_min)+'\t'+'\t'.join(str(i) for i in dislist_5ssnt)+'\n'
    f.write(string)
f.close()


f = open(outprefix+'_all_DG_distance.txt','w')
f.write('DG\treads#\tleft_arm\tright_arm\tleft_loc\tright_loc\tmin_L_pos\tmin_R_pos\tmin_distance\t5ssnt_L_pos\t5ssnt_R_pos\t5ssnt_distance\n')
for DG in newDGspan:
    dislist_min = get_min_distance_pos_from_newDGspan(newDGspan[DG][0], newDGspan[DG][1], matrix_PDB_distance, bpinfo, 1, 12994)
    dislist_5ssnt = get_5_6ssnt_distance_from_newDGspan(newDGspan[DG][0], newDGspan[DG][1], matrix_PDB_distance, bpinfo, 1, 12994, 3, 7)
    DG_left_start = str(int(newDGspan[DG][0][1])-1+1)
    DG_left_end   = str(int(newDGspan[DG][0][2])-1+1)
    DG_right_start = str(int(newDGspan[DG][1][1])-1+1)
    DG_right_end   = str(int(newDGspan[DG][1][2])-1+1)
    string = str(DG)+'\t'+str(len(dgdict[DG]))+'\t'+DG_left_start+'-'+DG_left_end+'\t'+DG_right_start+'-'+DG_right_end+'\t'+str(get_esDGs(newDGspan[DG][0], ESinfo))+'\t'+ \
    str(get_esDGs(newDGspan[DG][1], ESinfo))+'\t'+'\t'.join(str(i) for i in dislist_min)+'\t'+'\t'.join(str(i) for i in dislist_5ssnt)+'\n'
    f.write(string)
f.close()
