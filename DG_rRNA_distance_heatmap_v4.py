"""
minjiezhang123@gmail.com    2020-12-16      python 3

"""


#1. input and output setup
################################################################################
################################################################################
#this section sets up the input and output
import sys, argparse, numpy, os, re, itertools, random, math, pysam, RNA
from datetime import datetime
from sklearn.metrics import roc_curve, auc
import seaborn as sns
import matplotlib.pyplot as plt
from math import floor, ceil
from itertools import product
import matplotlib as mpl
from Bio.PDB.PDBParser import PDBParser

if len(sys.argv) < 3:
    print("Usage:           python DG_identity.py  sam_crssant  shape_bedpragh  shape_cutoff  bp_arc_file  4v6x.cif/4v6x_distance.txt  DG_reads_cutoff  distance_cutoff  DGcommon_ratio  DG/reads  winbin  outputprefix")
    print("sam_crssant:     sam file generated by crssant.py")
    print("shape_bedpragh:  shape activity of each nucleotides, in bedgraph format")
    print("shape_cutoff:    cut off value for shape data. positive data will be used to plot Cyto-ME analysis")
    print("bp_arc_file:     base pair information generated from PDB file")
    print("4v6x_distance.txt:   matrix_PDB_distance.txt generated from 4v6x")
    print("DG_reads_cutoff: minimum reads number of each DG")
    print("distance_cutoff: minimum distance was considered as tertiary structure, otherwise was considered as inter-molecular interactions")
    print("DGcommon_ratio:  minimum ratio to call the common region of each DG")
    print("winbin:          length of winbin, eg: 5"      )
    print("outputprefix                                     ")
    sys.exit()

inputsam = open(sys.argv[1],'r')
shape_bedpragh = open(sys.argv[2],'r')
shape_cutoff = float(sys.argv[3])
arcfile = open(sys.argv[4],'r')
PDBfile = sys.argv[5]
minreads = int(sys.argv[6])
mindistance = int(sys.argv[7])
DGcommoncutoff = float(sys.argv[8])
DGorReads = sys.argv[9]
#target_region = sys.argv[7]
winbin=int(sys.argv[10])
outprefix = sys.argv[11]

################################################################################


#2. subfunctions
################################################################################
def timenow(): return str(datetime.now())[:-7]

def mergeCIGAR(CIGAR): 
    #merge all operations that consume the reference, i.e. MI=X
    #example: 1S2M3N4M5I6M7S -> 1S2M3N10M7S 
    ops = re.findall('\d+[MNISH=X]', CIGAR) #all that consume query
    newops = [ops[0]]
    for op in ops[1:]: #concatenate all internal ops that consume query [MIS=X
        if op[-1] not in "I=X":
            if newops[-1][-1]=="M" and op[-1]=="M":
                newops[-1] = str(int(newops[-1][:-1])+int(op[:-1]))+"M"
            else: newops.append(op)
    newCIGAR = ("".join(str(i) for i in newops))
    return newCIGAR


def getsegs(line, segs): #turn an alignment into segs [(RNAME, STRAND L, R), ...]
    align = line.split()
    RNAME, POS, CIGAR = align[2], int(align[3]), align[5]
    STRAND = '-' if '{0:012b}'.format(int(align[1]))[-5] == '1' else '+'
    if align[0] not in segs: segs[align[0]] = [] #store all gaps from this CIGAR string, each as a 3-tuple.
    seglens = [int(i[:-1]) for i in re.findall('[0-9]+M', mergeCIGAR(CIGAR))] #seg lengths
    Ns =[i.rstrip('0123456789') for i in mergeCIGAR(CIGAR).split('M')]
    rx = [] #reference consumed: MD=X
    for N in Ns:
        rx.append(sum([int(i[:-1]) for i in re.findall('[0-9]+[ND=X]', N)]))
    for i in range(len(seglens)): #combine ref and segment lengths to make the junctions
        l, r = POS+sum(rx[:i+1])+sum(seglens[:i]), POS+sum(rx[:i+1])+sum(seglens[:i+1])-1
        if (RNAME, int(l), int(r), STRAND) not in segs[align[0]]: segs[align[0]].append((RNAME, int(l), int(r), STRAND))
        segs[align[0]].sort()
    #print(segs[align[0]])
    if len(segs[align[0]]) == 2: return segs[align[0]]
    
    
def normdist(list1,list2):
    mu1=np.mean(list1); sigma1 =np.std(list1)
    mu2=np.mean(list2); sigma2 =np.std(list2)
    overlap = NormalDist(mu1, sigma1).overlap(NormalDist(mu2, sigma2))
    return overlap


def getDGspan(DGspan):
    #DGspan['12S,12S,0']=[[('hs12S','2','22','+'),('hs12S','270','295','+')], [('hs12S','3','24','+'),('hs12S','285','300','+')]]
    #DGspan['12S,12S,1']=[[('hs12S', 8, 20, '+'), ('hs12S', 108, 137, '+')], [('hs12S', 6, 24, '+'), ('hs12S', 106, 145, '+')]]
    for DG in DGspan:
        DGslist=DGspan[DG]
        #print(DG)
        #print(DGspan[DG][0],DGspan[DG][-1])
        segls, segle, segrs, segre = int(DGslist[0][0][1]), int(DGslist[0][0][2]), int(DGslist[0][1][1]), int(DGslist[0][1][2])
        for i in range(1,len(DGslist),1):
            if int(DGslist[i][0][1]) < segls: segls=int(DGslist[i][0][1])
            if int(DGslist[i][0][2]) > segle: segle=int(DGslist[i][0][2])
            if int(DGslist[i][1][1]) < segrs: segrs=int(DGslist[i][1][1])
            if int(DGslist[i][1][2]) > segre: segre=int(DGslist[i][1][2])
        DGspan[DG]=[[DGslist[0][0][0],segls,segle,segle-segls+1],[DGslist[0][1][0],segrs,segre,segre-segrs+1]]
    return DGspan
    
    
def getOverlap(a, b): 
    overlap = int(min(int(a[2]),int(b[2]))) - int(max(int(a[1]),int(b[1])))
    readslen = (int(b[2]) - int(b[1]))/2
    if overlap >1 and overlap >= readslen: seganno = "Ture"
    else: seganno = "False"
    return seganno


def coveragenorm(dglist,dgspan,cutoff):
    #dglist: [[chr1,1,15,+],[chr1,31,45,+]], [[chr1,2,13,+],[chr1,33,43,+]], [[chr1,5,20,+],[chr1,40,50,+]]...
    #dgspan: [[chr1,1,25,25],[chr1,30,50,25]]]
    #cutoff: 0.8
    dgspannew=[]; count=-1
    for arm in dgspan:
        poscoverage = {};
        dgstart=0; dgend=0; count+=1
        for i in range(int(arm[1]),int(arm[2])+1,1): poscoverage[i] = 0 #initialize the pos coverage
        
        for seg in dglist:
            if getOverlap(arm, seg[count]) == "Ture":
                for i in range(int(seg[count][1]),int(seg[count][2])+1,1): poscoverage[i] += 1
        for i in range(int(arm[1]),int(arm[2])+1,1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgstart = i; break;
        for i in range(int(arm[2]),int(arm[1]),-1):
            if poscoverage[i]/max(poscoverage.values()) >= cutoff:  dgend = i; break;
        len = dgend - dgstart + 1
        dgspannew.append([arm[0],str(dgstart),str(dgend), seg[count][3]])
    return dgspannew
"""
dglist=[[['chr1',1,15,'+'],['chr1',31,45,'+']], [['chr1',2,13,'+'],['chr1',33,43,'+']], [['chr1',5,20,'+'],['chr1',40,50,'+']]]
dgspan=[['chr1','1','25','25'],['chr1','30','50','25']]
cutoff=0.6
print(coveragenorm(dglist,dgspan,cutoff))
output: [['chr1', '2', '15', '14', '+'], ['chr1', '33', '45', '11', '+']]
"""
"""
dglist=[[('hs45S', 11867, 11894, '+'), ('hs45S', 11965, 11990, '+')], [('hs45S', 11874, 11901, '+'), ('hs45S', 11961, 11973, '+')], [('hs45S', 11872, 11886, '+'), ('hs45S', 11977, 11991, '+')], [('hs45S', 11874, 11898, '+'), ('hs45S', 11954, 11972, '+')], [('hs45S', 11875, 11903, '+'), ('hs45S', 11952, 11970, '+')], [('hs45S', 11875, 11896, '+'), ('hs45S', 11965, 11986, '+')], [('hs45S', 11875, 11890, '+'), ('hs45S', 11967, 11985, '+')], [('hs45S', 11877, 11903, '+'), ('hs45S', 11948, 11967, '+')], [('hs45S', 11867, 11883, '+'), ('hs45S', 11976, 11991, '+')], [('hs45S', 11867, 11885, '+'), ('hs45S', 11973, 11990, '+')], [('hs45S', 11867, 11885, '+'), ('hs45S', 11972, 11990, '+')]]
dgspan=[['hs45S', 11832, 11925, 94], ['hs45S', 11927, 12039, 113]]
cutoff=0.8
print(dglist)
print(dgspan)
print(coveragenorm(dglist,dgspan,cutoff))
"""

"""
#bed1 [chr,14,23] -> [3:11-15; 4:16-20; 5:21-25]
#bed2 [chr,23,45] -> [5:21-25; 6:26-30; 7:31-35; 8:36-40; 9:41-45]
#out: [(3, 6), (4, 7), (5, 8)]
def getPos(bed1, bed2, winbin,start):
    chr1, start1, end1 = bed1[0], int(bed1[1])-int(start)+1, int(bed1[2])-int(start)+1
    chr2, start2, end2 = bed2[0], int(bed2[1])-int(start)+1, int(bed2[2])-int(start)+1
    pos1 = []; pos2 = []; pos1new = []; pos2new = []
    for i in range(ceil(start1/winbin), ceil(end1/winbin)+1, 1):
        pos1.append(i)
    for i in range(ceil(start2/winbin), ceil(end2/winbin)+1, 1):
        pos2.append(i)
    if len(pos1) >= len(pos2):
        max = len(pos1); min = len(pos2)
        start = int((max-min)/2);   end = start + min
        pos1new = pos1[start:end];  pos2new = pos2
    else:
        max = len(pos2); min = len(pos1)
        start = int((max-min)/2);   end = start + min
        pos1new = pos1;  pos2new = pos2[start:end][::-1]
    return list(zip(pos1new, pos2new))
"""

def DNA_complement1(sequence):
    comp_dict = {"A":"T","T":"A","G":"C","C":"G","a":"t","t":"a","g":"c","c":"g"}
    sequence_list = list(sequence)
    sequence_list = [comp_dict[base] for base in sequence_list]
    string = ''.join(sequence_list)
    return string


def getfa(bed,ref):
    #bed: [chr1,12,25,+]
    RNAME,fastart,faend,STRAND = bed[0], bed[1], bed[2], bed[3]
    faseq = ''
    if STRAND == '+': faseq = ref.fetch(RNAME, int(fastart)-1, int(faend))
    if STRAND == '-': faseq = (DNA_complement1(ref.fetch(RNAME, int(fastart)-1, int(faend))))[::-1]
    return faseq.replace("T", "U")


# get trimmean arm length (trimmean: 0.7)
def get_armlen(newDGspan):
    # newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
    larmlen = []; rarmlen = []
    for DG in newDGspan:
        larmlen.append(int(newDGspan[DG][0][2])-int(newDGspan[DG][0][1])+1)
        rarmlen.append(int(newDGspan[DG][1][2])-int(newDGspan[DG][1][1])+1)
    larmlen.sort()
    rarmlen.sort()
    leftlen = int(larmlen[int(len(larmlen)*0.8)]/5)*5
    rightlen = int(larmlen[int(len(rarmlen)*0.8)]/5)*5
    return leftlen,rightlen


# get left right no-BP matrix
def get_armseq(newDGspan, bplist):
    # newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
    # bpinfo:   [[1HR2, 6, 112], [1HR2, 7, 111]...]
    leftlen,rightlen = get_armlen(newDGspan) # trimmean arm length
    #matrix_size = min(leftlen,rightlen)
    matrix_size = 35
    matrix_noBP = numpy.zeros((matrix_size,matrix_size))
    noBPset = []
    for DG in newDGspan:
        leftarm = []; rightarm = []
        for i in range(0,matrix_size,1):   leftarm.append(0)
        for i in range(0,matrix_size,1):   rightarm.append(0)
        lcount = 0; rcount = 0
        if str(newDGspan[DG][0][0])=='hs45S' and str(newDGspan[DG][1][0])=='hs45S':
            # left arm
            for i in range(0, matrix_size, 1):
                lcount -= 1
                if int(newDGspan[DG][0][2])+lcount+1 >= int(newDGspan[DG][0][1]):
                    if bplist[int(newDGspan[DG][0][2])+lcount+1] == 1:  leftarm[lcount] = 0
                    else: leftarm[lcount] = 1
            # right arm
            for j in range(0, matrix_size, 1):
                rcount -= 1
                if int(newDGspan[DG][1][2])+rcount+1 >= int(newDGspan[DG][1][1]):
                    if bplist[int(newDGspan[DG][1][2])+rcount+1] == 1:  rightarm[rcount] = 0
                    else: rightarm[rcount] = 1
        
        # get no-BP sets
        for i in range(0, len(leftarm), 1):
            for j in range(0, len(rightarm), 1):
                if leftarm[i]*rightarm[j] == 1:
                    matrix_noBP[j,i] += 1
                    #leftpos = i+1; rightpos = j+1
                    #noBPset.append([rightpos,leftpos])
                                    
    return matrix_noBP
"""            
newDGspan={}
newDGspan[1] = [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]
newDGspan[2] = [['1HR2', '2', '10', '+'], ['1HR2', '28', '34', '+']]
newDGspan[3] = [['1HR2', '2', '11', '+'], ['1HR2', '28', '35', '+']]
newDGspan[4] = [['1HR2', '2', '10', '+'], ['1HR2', '28', '34', '+']]
bplist = [1,2,3,4,5,6,8,9,10,11,28,29,31,32,33,34,35]
print(get_armlen(newDGspan))
print(get_armseq(newDGspan, bplist))

noBPset = (get_armseq(newDGspan, bplist))
noBPdict = {}
for noBP in noBPset:
    noBP_key = str(noBP[0])+'-'+str(noBP[1])
    if noBP_key not in noBPdict: noBPdict[noBP_key] = 0
    noBPdict[noBP_key] += 1
    
for noBP_key in noBPdict:
    plt.scatter(int(noBP_key.split('-')[0]),int(noBP_key.split('-')[1]),color='b',s=10*noBPdict[noBP_key])
plt.show()
"""    


## test whether bed1 was included by bed2:
def bedinregions(bed, regions):
    # bed = ['hs45S', '3998', '4012', '+']
    # regions = [['hs45S', '3654', '5523'], ['hs45S', '6600', '6757'], ['hs45S', '7924', '12994']]
    bedanno = 'False'
    for targetbed in regions:
        if str(bed[0]) == str(targetbed[0]):
            if int(bed[1]) >= int(targetbed[1]) and int(bed[2]) <= int(targetbed[2]):
                bedanno = 'True'
                #print(bedanno)
                continue
    return bedanno

 
## get newDGspan with two arms located in target regions:
# newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
def get_targetDG(newDGspan, targetregion):
    #targetregion: hs45S:3654:5523,hs45S:6600:6757,hs45S:7924:12994
    regions = []; newDGspan_filter = {}
    for i in targetregion.split(','): regions.append(i.split(':'))
    for DG in newDGspan:
        if bedinregions(newDGspan[DG][0], regions) == 'True' and bedinregions(newDGspan[DG][1], regions) == 'True':
            if DG not in newDGspan_filter: newDGspan_filter[DG] = []
            newDGspan_filter[DG] = newDGspan[DG]
    return newDGspan_filter
        
        
        
## classfy DGs to DG_leftarm, DG_rightarm, DG_LRarm
# DG_leftarm:  DGs Left arm contain ss nts at target region
# DG_rightarm: DGs right arm contain ss nts at target region
# DG_LRarm:    DGs left && right arm contaiin ss nts 
def select_DG(newDGspan, bplist, regions, regione):
    # newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}
    # bpinfo:   [[1HR2, 6, 112], [1HR2, 7, 111]...]
    DG_leftarm = {}; DG_rightarm = {};  DG_LRarm = {}
    for DG in newDGspan:
        if str(newDGspan[DG][0][0])=='hs45S' and str(newDGspan[DG][1][0])=='hs45S':
            # left arm
            for i in range(int(newDGspan[DG][0][2])-regions+1, int(newDGspan[DG][0][2])-regione, -1):
                if bplist[i] == 0: DG_leftarm[DG] = newDGspan[DG]; continue
            for j in range(int(newDGspan[DG][1][2])-regions+1, int(newDGspan[DG][1][2])-regione, -1):
                if bplist[j] == 0: DG_rightarm[DG] = newDGspan[DG]; continue
        if DG in DG_leftarm and DG in DG_rightarm:  
            DG_LRarm[DG] = newDGspan[DG]
    #print(DG_leftarm)
    #print(DG_rightarm)
    #print(DG_LRarm)
    return DG_leftarm, DG_rightarm, DG_LRarm
"""            
newDGspan={}
newDGspan[1] = [['hs45S', '2', '9', '+'], ['hs45S', '28', '33', '+']]
newDGspan[2] = [['hs45S', '2', '10', '+'], ['hs45S', '28', '34', '+']]
newDGspan[3] = [['hs45S', '2', '11', '+'], ['hs45S', '28', '35', '+']]
newDGspan[4] = [['hs45S', '2', '10', '+'], ['hs45S', '28', '34', '+']]
bplist = [1,2,3,4,5,6,8,9,10,11,28,29,31,32,33,34,35]

DG_leftarm = {}; DG_rightarm = {};  DG_LRarm = {}
DG_leftarm, DG_rightarm, DG_LRarm = select_DG(newDGspan, bplist, 3, 4)

output:
>>> DG_leftarm
{1: [['hs45S', '2', '9', '+'], ['hs45S', '28', '33', '+']], 2: [['hs45S', '2', '10', '+'], ['hs45S', '28', '34', '+']], 4: [['hs45S', '2', '10', '+'], ['hs45S', '28', '34', '+']]}
>>> DG_rightarm
{1: [['hs45S', '2', '9', '+'], ['hs45S', '28', '33', '+']]}
>>> DG_LRarm
{1: [['hs45S', '2', '9', '+'], ['hs45S', '28', '33', '+']]}
"""    

################################################################################



#3 start processing the sam file.
################################################################################
print(timenow()+" Collecting alignments into a dictionary ...")
dgdict = {}; #{sample-dgid: [(RNAME, str(ls), str(le), STRAND),(RNAME, str(rs), str(re), STRAND)] [] []..}
DGspan = {}; DGs=[];  segs={}; newDGspan = {}; newDGspan_filter = {}

if DGorReads == "DG":
    for line in inputsam:
        #build the dgdict: dictionary of all segment terminals
        #format: dgid:[RNAME, STRAND, lstart, lend, rstart rend]
        if line[0]=='@': continue
        align = line.split('\t')
        dgloc = len(align); dgid = None #check where the dgid is
        if align[dgloc-2][:2]=='DG': dgid = (align[dgloc-2].split(':')[-1])
        else: sys.exit("Error, DG ID not found in column 19")
        sample = align[0].split('-')[-1]
        if dgid not in DGs: DGs.append(dgid)
        dgid_sample = sample+'-'+dgid
    
        if dgid not in dgdict: dgdict[dgid]=[] #initialize the item
        if getsegs(line,segs):  dgdict[dgid].append(getsegs(line,segs))
        if dgid not in DGspan: DGspan[dgid]=[]
        if getsegs(line,segs):  DGspan[dgid].append(getsegs(line,segs))

    inputsam.close()

    ## get DGspan of raw data
    DGspan = getDGspan(DGspan)

    ## get the common region of each DG
    for DG in DGspan:
        if len(dgdict[DG]) >= minreads:  # filter DG based on DG_reads_cutoff parameter
            newDGspan[DG] = coveragenorm(dgdict[DG],DGspan[DG],DGcommoncutoff)
        
        
            
if DGorReads == "reads":
    for line in inputsam:
        #build the dgdict: dictionary of all segment terminals
        #format: dgid:[RNAME, STRAND, lstart, lend, rstart rend]
        if line[0]=='@': continue
        align = line.split('\t')
        readID = align[0]
        if readID not in newDGspan: newDGspan[readID] = []
        if getsegs(line,segs):  newDGspan[readID] = getsegs(line,segs)
    inputsam.close()

## filter newDGspan that located in targe regions:
#newDGspan_filter = get_targetDG(newDGspan, 'hs45S:3654:5523,hs45S:6600:6757,hs45S:7924:12994')
################################################################################



#4. Get base pairing and noBP information:
################################################################################
print(str(datetime.now())[:-7], "Get base pairing information ...")
## read dsRNA information (bp_acr_file) 
bpinfo = {} #[[1HR2, 6, 112], [1HR2, 7, 111]...]
lines = arcfile.readlines()[1:] # remove header
for line in lines:
    #track graphType=arc
    #1HR2    6       112     stemloop1
    chr, start, end, stem = line.rstrip('\n').split('\t')
    bpinfo[int(start)] = 1
    bpinfo[int(end)] = 1
arcfile.close()
lines = []

for i in range(1, 13358, 1):
    if i not in bpinfo:
        bpinfo[i] = 0


## get noBP list of 18S 28S and 5.8S
noBPlist_18S = {};  noBPlist_28S = {}; noBPlist_58S={}
for i in range(1, 12995, 1):
    if i >= 3654 and i <= 5523: noBPlist_18S[i] = bpinfo[i]
    if i >= 6600 and i <= 6757: noBPlist_58S[i] = bpinfo[i]
    if i >= 7924 and i <= 12994: noBPlist_28S[i] = bpinfo[i]
################################################################################



#5 read shape data
################################################################################
shapevalue = {} #{pos: value ...}
print(str(datetime.now())[:-7], "Get shape information ...")
for line in shape_bedpragh:
    #track graphType=arc
    #1HR2    6       112     0.98
    chr, start, end, value = line.rstrip('\n').split('\t')
    if float(value) >= 0:   shapevalue[int(end)] = float(value)
    else:   shapevalue[int(end)] = 0
shape_bedpragh.close()


## get the activited nts
#for i in shapevalue:
    #if shapevalue[i] >= shape_cutoff:   shape_list.append(i)

## get noBP list of 18S 28S and 5.8S    
shape_nt_18S = {};  shape_nt_28S = {}; shape_nt_58S={}
for i in shapevalue:
    if i >= 3654 and i <= 5523: shape_nt_18S[i] = shapevalue[i]
    if i >= 6600 and i <= 6757: shape_nt_58S[i] = shapevalue[i]
    if i >= 7924 and i <= 12994: shape_nt_28S[i] = shapevalue[i]


#5. Get distance information from PDB files:
################################################################################
## read PDB file and generate the distance matrix
print(str(datetime.now())[:-7], "Get distance information from PDB files ...")

if "cif" in PDBfile or "pdb" in PDBfile:
    numcol = 13357; numrow = 13357
    chainpos = {}
    for i in range(3655, 5525, 1):  chainpos[i] = ['B2', i-3654]
    for i in range(6601, 6759, 1):  chainpos[i] = ['A8', i-6600]
    for i in range(7925, 12996, 1): chainpos[i] = ['A5', i-7924]
    
    matrix_PDB_distance = numpy.zeros((13357,13357))

    from Bio.PDB import *
    parser = MMCIFParser()
    structure = parser.get_structure("Sample", PDBfile)
    group = "O2'"

    for i in chainpos:
        for j in chainpos:
            if chainpos[i][1] in structure[0][chainpos[i][0]] and chainpos[j][1] in structure[0][chainpos[j][0]]:
                if group in structure[0][chainpos[i][0]][chainpos[i][1]] and group in structure[0][chainpos[j][0]][chainpos[j][1]]:
                    matrix_PDB_distance[(i-1), (j-1)] = structure[0][chainpos[i][0]][chainpos[i][1]][group] - structure[0][chainpos[j][0]][chainpos[j][1]][group]
    # numpy.savetxt("matrix_PDB_distance.txt", matrix_PDB_distance, fmt="%s", delimiter=",")
    # matrix_PDB_distance = numpy.loadtxt("matrix_PDB_distance.txt",delimiter=",")

if "txt" in PDBfile:
    matrix_PDB_distance = numpy.loadtxt(PDBfile, delimiter=",")

################################################################################    




#6. Plot heatmap of noBP distance using 5nt winbin
################################################################################

## get noBP within winbin:
# start = 2
# end = 18
# noBPlist = [4,5,6,9,10,13,14]
# winbin = 5
# output: {1: [4, 5, 6], 2: [9, 10], 3: [13, 14], 4: []}
def get_winbin_shape(start, end, noBPlist, shape_cutoff, winbin):
    noBPdict = {}
    start_winbin = 1; end_winbin = ceil((int(end)-int(start)+1)/winbin)
    for i in range(start_winbin, end_winbin+1, 1):  noBPdict[i] = []
    for i in noBPlist:
        if noBPlist[i] >= shape_cutoff:
            pos = ceil((i-start+1)/winbin)
            noBPdict[pos].append(i)
    return noBPdict


def get_winbin_ssnts(start, end, noBPlist, winbin):
    noBPdict = {}
    start_winbin = 1; end_winbin = ceil((int(end)-int(start)+1)/winbin)
    for i in range(start_winbin, end_winbin+1, 1):  noBPdict[i] = []
    for i in noBPlist:
        if noBPlist[i] == 0:
            pos = ceil((i-start+1)/winbin)
            noBPdict[pos].append(i)
    return noBPdict


def get_aver_distance(matrix_PDB_distance, noBPdict):
    matrix_aver_distance_0to20 = numpy.zeros((len(noBPdict),len(noBPdict)))
    matrix_aver_distance_20to40 = numpy.zeros((len(noBPdict),len(noBPdict)))
    matrix_aver_distance_40 = numpy.zeros((len(noBPdict),len(noBPdict)))
    for i in noBPdict:
        for j in noBPdict:
            distances = []
            for x in list(itertools.product(noBPdict[i], noBPdict[j])):
                if matrix_PDB_distance[x[0]-1, x[1]-1] > 0: distances.append(matrix_PDB_distance[x[0]-1, x[1]-1])
            if distances:
                if numpy.min(distances) > 0 and numpy.min(distances)<=20: matrix_aver_distance_0to20[i-1, j-1] = 1
                if numpy.min(distances) > 20 and numpy.min(distances)<=40: matrix_aver_distance_20to40[i-1, j-1] = 1
                if numpy.min(distances) > 40: matrix_aver_distance_40[i-1, j-1] = 1
    for i in range(0, len(noBPdict), 1):
        for j in range(0, len(noBPdict), 1):
            if matrix_aver_distance_0to20[i,j] == 0: matrix_aver_distance_0to20[i,j] = 'nan'
            if matrix_aver_distance_20to40[i,j] == 0: matrix_aver_distance_20to40[i,j] = 'nan'
            if matrix_aver_distance_40[i,j] == 0: matrix_aver_distance_40[i,j] = 'nan'
    return matrix_aver_distance_0to20,matrix_aver_distance_20to40,matrix_aver_distance_40    
    

#7. Plot heatmap of noBP distance of SHARC data
################################################################################
# newDGspan:    {'1HR2,1HR2,0': [['1HR2', '2', '9', '+'], ['1HR2', '28', '33', '+']]}

def getPos(bed1, bed2, winbin,start):
    chr1, start1, end1 = bed1[0], int(bed1[1])-int(start)+1, int(bed1[2])-int(start)+1
    chr2, start2, end2 = bed2[0], int(bed2[1])-int(start)+1, int(bed2[2])-int(start)+1
    pos1 = []; pos2 = []; pos1new = []; pos2new = []
    for i in range(ceil(start1/winbin), ceil(end1/winbin)+1, 1):
        pos1.append(i)
    for i in range(ceil(start2/winbin), ceil(end2/winbin)+1, 1):
        pos2.append(i)
    return list(itertools.product(pos1,pos2))


def get_min_distance_pos_from_newDGspan(newDGspan, matrix_PDB_distance, noBPlist, start, end, winbin):
    start_winbin = 1; end_winbin = ceil((int(end)-int(start)+1)/winbin)
    #SHARC_pairwise_dict = numpy.zeros((end_winbin,end_winbin))
    SHARC_pairwise_dict_0to20 = numpy.zeros((end_winbin,end_winbin))
    SHARC_pairwise_dict_20to40 = numpy.zeros((end_winbin,end_winbin))
    SHARC_pairwise_dict_40 = numpy.zeros((end_winbin,end_winbin))
    for DG in newDGspan:
        dislist = []; leftlist = []; rightlist = []
        for i in range(int(newDGspan[DG][0][1]), int(newDGspan[DG][0][2])+1, 1):
            if noBPlist[i] == 0: leftlist.append(i)
        for j in range(int(newDGspan[DG][1][1]), int(newDGspan[DG][1][2])+1, 1):
            if noBPlist[j] == 0: rightlist.append(j)
        if leftlist and rightlist:
            loop_val = [leftlist,rightlist]
            for i in product(*loop_val):
                if matrix_PDB_distance[(i[0]-1), (i[1]-1)] > 0:
                    dislist = [i[0], i[1], matrix_PDB_distance[(i[0]-1), (i[1]-1)]]
                    continue
            for i in product(*loop_val):
                if matrix_PDB_distance[(i[0]-1), (i[1]-1)] > 0 and matrix_PDB_distance[(i[0]-1), (i[1]-1)] < dislist[2]:
                    dislist = [i[0], i[1], matrix_PDB_distance[(i[0]-1), (i[1]-1)]]
            if dislist:
                if dislist[2]>0 and dislist[2]<=20: SHARC_pairwise_dict_0to20[ceil((dislist[0]-int(start)+1)/winbin)-1, ceil((dislist[1]-int(start)+1)/winbin)-1] += 1
                if dislist[2]>20 and dislist[2]<=40: SHARC_pairwise_dict_20to40[ceil((dislist[0]-int(start)+1)/winbin)-1, ceil((dislist[1]-int(start)+1)/winbin)-1] += 1
                if dislist[2]>40: SHARC_pairwise_dict_40[ceil((dislist[0]-int(start)+1)/winbin)-1, ceil((dislist[1]-int(start)+1)/winbin)-1] += 1
    for i in range(0, end_winbin, 1):
        for j in range(0, end_winbin, 1):
            if SHARC_pairwise_dict_0to20[i,j] <= 10: SHARC_pairwise_dict_0to20[i,j] = 'nan'
            else: SHARC_pairwise_dict_0to20[i,j] = math.sqrt(SHARC_pairwise_dict_0to20[i,j])
            if SHARC_pairwise_dict_20to40[i,j] <= 10: SHARC_pairwise_dict_20to40[i,j] = 'nan'
            else: SHARC_pairwise_dict_20to40[i,j] = math.sqrt(SHARC_pairwise_dict_20to40[i,j])   
            if SHARC_pairwise_dict_40[i,j] <= 10: SHARC_pairwise_dict_40[i,j] = 'nan'
            else: SHARC_pairwise_dict_40[i,j] = math.sqrt(SHARC_pairwise_dict_40[i,j])
    return SHARC_pairwise_dict_0to20,SHARC_pairwise_dict_20to40,SHARC_pairwise_dict_40


def DG_shuffle(newDGspan, chr, start, end, maxcount):
    # output newDGspan in to bed1 and bed2
    newDGspan_shuffled = {}; count = 0
    bed1 = open('bed1.bed','w')
    bed2 = open('bed2.bed','w')
    for DG in newDGspan:
        left_arm = newDGspan[DG][0][0]+'\t'+str(newDGspan[DG][0][1])+'\t'+str(newDGspan[DG][0][2])+'\n'
        right_arm = newDGspan[DG][1][0]+'\t'+str(newDGspan[DG][1][1])+'\t'+str(newDGspan[DG][1][2])+'\t'+DG+'\n'
        bed1.write(left_arm)
        bed2.write(right_arm)
    bed1.close()
    bed2.close()
    # output incl.bed and genome.bed
    inclbed = open('incl.bed','w')
    inclbed.write(chr+'\t'+str(start)+'\t'+str(end)+'\n')
    inclbed.close()
    genome = open('hs45S_genome.bed','w')
    genome.write(chr+'\t13357\n')
    genome.close()
    # bedtools shuffle
    os.system("bedtools shuffle -incl incl.bed -i bed1.bed -g hs45S_genome.bed > bed1_shuffled.bed")
    os.system("bedtools shuffle -incl incl.bed -i bed1.bed -g hs45S_genome.bed >> bed1_shuffled.bed")
    #os.system("bedtools shuffle -incl incl.bed -i bed1.bed -g hs45S_genome.bed >> bed1_shuffled.bed")
    os.system("bedtools shuffle -incl incl.bed -i bed2.bed -g hs45S_genome.bed > bed2_shuffled.bed")
    os.system("bedtools shuffle -incl incl.bed -i bed2.bed -g hs45S_genome.bed >> bed2_shuffled.bed")
    #os.system("bedtools shuffle -incl incl.bed -i bed2.bed -g hs45S_genome.bed >> bed2_shuffled.bed")
    os.system("paste bed1_shuffled.bed  bed2_shuffled.bed > bed1_2_shuffled.bed")
    # import shuffled
    inputbedpe=open('bed1_2_shuffled.bed','r')
    for line in inputbedpe:
        count += 1
        align = line.rstrip('\n').split('\t')
        keyID = align[6]+'-'+str(count)
        if int(align[2]) <= int(align[4]) and count<=maxcount:
            newDGspan_shuffled[keyID] = [[align[0],int(align[1]),int(align[2])],[align[3],int(align[4]),int(align[5])]]
        #else:
        #    newDGspan_shuffled[keyID] = [[align[3],int(align[4]),int(align[5])], [align[0],int(align[1]),int(align[2])]]
    inputbedpe.close()
    os.system("rm incl.bed  bed1.bed  bed2.bed  hs45S_genome.bed  bed1_shuffled.bed  bed2_shuffled.bed  bed1_2_shuffled.bed")
    return newDGspan_shuffled


cdict = {'red':   [(0.0,  1.0, 1.0),(0.6,  0.8, 0.8),(0.8,  0.5, 0.5),(1.0,  0.0, 0.0)],
         'green': [(0.0,  1.0, 1.0),(0.6,  0.8, 0.8),(0.8,  0.5, 0.5),(1.0,  0.0, 0.0)],
         'blue':  [(0.0,  1.0, 1.0),(0.6,  0.8, 0.8),(0.8,  0.5, 0.5),(1.0,  0.0, 0.0)]}
cmp1 = mpl.colors.LinearSegmentedColormap('name',cdict)



def plot_heatmap(matrix_aver_distance, SHARC_pairwise_dict, start, end, maxvalue, rownum):
    axes = plt.subplot(3,2,rownum)
    mask = numpy.zeros_like(matrix_aver_distance)
    mask[numpy.triu_indices_from(mask)] = True
    sns.heatmap(matrix_aver_distance,cmap=cmp1, mask=mask, vmin=0, vmax=1, zorder=10)
    sns.heatmap(SHARC_pairwise_dict,cmap=cmp1, vmin=0, vmax=maxvalue, zorder=10)
    for x in range(0, ceil(((int(end)-int(start)+1)/winbin)+(800/winbin)), int(800/winbin)): plt.vlines(x, 0, int(ceil(int(end)-int(start)+1)/winbin), color = "silver", linestyles = "solid", linewidth=1, zorder=1)
    for x in range(0, ceil(((int(end)-int(start)+1)/winbin)+(800/winbin)), int(800/winbin)): plt.hlines(x, 0, int(ceil(int(end)-int(start)+1)/winbin), color = "silver", linestyles = "solid", linewidth=1, zorder=1)
    plt.plot([0, ceil((int(end)-int(start)+1)/winbin)],[0, ceil((int(end)-int(start)+1)/winbin)], linewidth=1, color = 'silver', zorder=15)
    sns.despine(top=False, right=False, left=False, bottom=False)
    axes.xaxis.set_ticklabels([])
    axes.yaxis.set_ticklabels([])
    plt.xticks([])
    plt.yticks([])
    #plt.savefig(outputname+"A.pdf")
    #plt.close()
    return



def plot_scatter(matrix_aver_distance, SHARC_pairwise_dict, start, end, winbin, maxvalue, scatter_color, rownum):
    # get PDB list
    xaixs = []; yaixs = []; colors=[]
    for i in range(0, len(matrix_aver_distance), 1):
        for j in range(0, len(matrix_aver_distance), 1):
            if matrix_aver_distance[i,j] > 1 and j >= i:
                xaixs.append(i+1); yaixs.append(j+1)
    # get sharc list
    x = []; y = []; size = []
    for i in range(0, len(SHARC_pairwise_dict), 1):
        for j in range(0, len(SHARC_pairwise_dict), 1):
            if SHARC_pairwise_dict[i,j] > 5 and j>=i:
                x.append(i+1); y.append(j+1);
                #size.append(SHARC_pairwise_dict[i,j]/maxvalue*20)
                if math.sqrt(SHARC_pairwise_dict[i,j]) <= math.sqrt(maxvalue): colors.append(math.sqrt(SHARC_pairwise_dict[i,j]))
                else: colors.append(math.sqrt(maxvalue))
    colors[0] = math.sqrt(math.sqrt(maxvalue))            
    # plot scatter plot
    ax = plt.subplot(5,2,rownum)
    plt.scatter(xaixs, yaixs, c='black', s=1, zorder=10)
    plt.scatter(y, x, c=colors, cmap='Greys', s=1, zorder=10)
    plt.gca().invert_yaxis()
    plt.plot([0, ceil((int(end)-int(start)+1)/winbin)],[0, ceil(((int(end)-int(start)+1)/winbin))], linewidth=1, color = 'silver', zorder=15)
    for x in range(0, int((end-start+1)/winbin), int(800/winbin)): plt.vlines(x, 1, ceil((end-start)/winbin), color = "silver", linewidth=1, linestyles = "solid", zorder=1)
    for x in range(0, int((end-start+1)/winbin), int(800/winbin)): plt.hlines(x, 1, ceil((end-start)/winbin), color = "silver", linewidth=1, linestyles = "solid", zorder=1)
    plt.vlines(ceil((end-start)/winbin), 1, ceil((end-start)/winbin), color = "silver", linestyles = "solid", linewidth=1, zorder=1)
    plt.hlines(ceil((end-start)/winbin), 1, ceil((end-start)/winbin), color = "silver", linestyles = "solid", linewidth=1, zorder=1)
    plt.xticks([])
    plt.yticks([])
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['bottom'].set_visible(False)
    ax.spines['left'].set_visible(False)
    return



"""
## plot 18S shape_sharc
print(str(datetime.now())[:-7], "Get shape distance info ...")
noBPdict = {}
noBPdict = get_winbin_shape(3654, 5523, shape_nt_18S, shape_cutoff, winbin)
matrix_aver_distance_0to20,matrix_aver_distance_20to40,matrix_aver_distance_40 = get_aver_distance(matrix_PDB_distance, noBPdict)
print(str(datetime.now())[:-7], "Get shrac distance info ...")
newDGspan_filter = {}
newDGspan_filter = get_targetDG(newDGspan, 'hs45S:3654:5523')
SHARC_pairwise_dict_0to20={}; SHARC_pairwise_dict_20to40={}; SHARC_pairwise_dict_40={}; 
SHARC_pairwise_dict_0to20,SHARC_pairwise_dict_20to40,SHARC_pairwise_dict_40=get_min_distance_pos_from_newDGspan(newDGspan_filter, matrix_PDB_distance, noBPlist_18S, 3654, 5523, winbin)

# plot scatter plot:
print(str(datetime.now())[:-7], "Plot shape_sharc scatter plot ...")
fig, ax = plt.subplots(figsize=(2,5.5))
distance_list = []
for i in range(0, len(SHARC_pairwise_dict_0to20), 1):
    for j in range(0, len(SHARC_pairwise_dict_0to20), 1):
        if SHARC_pairwise_dict_0to20[i,j] >= 5:
            distance_list.append(SHARC_pairwise_dict_0to20[i,j])
distance_list.sort()
max_value = distance_list[int(len(distance_list)*0.7)]
max_value = 5
print(max_value)
plot_heatmap(matrix_aver_distance_0to20, SHARC_pairwise_dict_0to20, 3654, 5523, max_value, 1)
plot_heatmap(matrix_aver_distance_20to40, SHARC_pairwise_dict_20to40, 3654, 5523, max_value, 3)
plot_heatmap(matrix_aver_distance_40, SHARC_pairwise_dict_40, 3654, 5523, max_value, 5)
#plt.savefig(outprefix+'_shape_sharc_scatter.pdf')
#plt.close()


# get shuffled DG
noBPdict = {}
noBPdict = get_winbin_shape(3654, 5523, shape_nt_18S, shape_cutoff, winbin)
matrix_aver_distance_0to20={}; matrix_aver_distance_20to40={}; matrix_aver_distance_40={}; 
matrix_aver_distance_0to20,matrix_aver_distance_20to40,matrix_aver_distance_40 = get_aver_distance(matrix_PDB_distance, noBPdict)
newDGspan_filter_shuffled = get_targetDG(DG_shuffle(newDGspan_filter,'hs45S',3654,5523, len(newDGspan_filter)),'hs45S:3654:5523')
SHARC_pairwise_dict_0to20={}; SHARC_pairwise_dict_20to40={}; SHARC_pairwise_dict_40={}; 
SHARC_pairwise_dict_0to20,SHARC_pairwise_dict_20to40,SHARC_pairwise_dict_40=get_min_distance_pos_from_newDGspan(newDGspan_filter_shuffled, matrix_PDB_distance, noBPlist_18S, 3654, 5523, winbin)

# plot scatter plot:
print(str(datetime.now())[:-7], "Plot shuffling shape_sharc scatter plot ...")
#fig, ax = plt.subplots(figsize=(2,5.5))
plot_heatmap(matrix_aver_distance_0to20, SHARC_pairwise_dict_0to20, 3654, 5523, max_value, 2)
plot_heatmap(matrix_aver_distance_20to40, SHARC_pairwise_dict_20to40, 3654, 5523, max_value, 4)
plot_heatmap(matrix_aver_distance_40, SHARC_pairwise_dict_40, 3654, 5523, max_value, 6)
#plt.savefig(outprefix+'_shape_sharc_scatter.pdf')
#plt.close()
plt.show()
"""


    

## plot 28S shape_sharc
print(str(datetime.now())[:-7], "Get shape distance info ...")
noBPdict = {}
noBPdict = get_winbin_shape(7924, 12994, shape_nt_28S, shape_cutoff, winbin)
matrix_aver_distance_0to20,matrix_aver_distance_20to40,matrix_aver_distance_40 = get_aver_distance(matrix_PDB_distance, noBPdict)
print(str(datetime.now())[:-7], "Get shrac distance info ...")
newDGspan_filter = {}
newDGspan_filter = get_targetDG(newDGspan, 'hs45S:7924:12994')
SHARC_pairwise_dict_0to20={}; SHARC_pairwise_dict_20to40={}; SHARC_pairwise_dict_40={}; 
SHARC_pairwise_dict_0to20,SHARC_pairwise_dict_20to40,SHARC_pairwise_dict_40=get_min_distance_pos_from_newDGspan(newDGspan_filter, matrix_PDB_distance, noBPlist_28S, 7924, 12994, winbin)

# plot scatter plot:
print(str(datetime.now())[:-7], "Plot shape_sharc scatter plot ...")
fig, ax = plt.subplots(figsize=(2,5.5))
distance_list = []
for i in range(0, len(SHARC_pairwise_dict_0to20), 1):
    for j in range(0, len(SHARC_pairwise_dict_0to20), 1):
        if SHARC_pairwise_dict_0to20[i,j] >= 5:
            distance_list.append(SHARC_pairwise_dict_0to20[i,j])
distance_list.sort()
max_value = distance_list[int(len(distance_list)*0.7)]
max_value = 10
print(max_value)
plot_heatmap(matrix_aver_distance_0to20, SHARC_pairwise_dict_0to20, 7924, 12994, max_value, 1)
plot_heatmap(matrix_aver_distance_20to40, SHARC_pairwise_dict_20to40, 7924, 12994, max_value, 3)
plot_heatmap(matrix_aver_distance_40, SHARC_pairwise_dict_40, 7924, 12994, max_value, 5)
#plt.savefig(outprefix+'_shape_sharc_scatter.pdf')
#plt.close()


# get shuffled DG
noBPdict = {}
noBPdict = get_winbin_shape(7924, 12994, shape_nt_28S, shape_cutoff, winbin)
matrix_aver_distance_0to20={}; matrix_aver_distance_20to40={}; matrix_aver_distance_40={}; 
matrix_aver_distance_0to20,matrix_aver_distance_20to40,matrix_aver_distance_40 = get_aver_distance(matrix_PDB_distance, noBPdict)
newDGspan_filter_shuffled = get_targetDG(DG_shuffle(newDGspan_filter,'hs45S',7925,12994, len(newDGspan_filter)),'hs45S:7924:12994')
SHARC_pairwise_dict_0to20={}; SHARC_pairwise_dict_20to40={}; SHARC_pairwise_dict_40={}; 
SHARC_pairwise_dict_0to20,SHARC_pairwise_dict_20to40,SHARC_pairwise_dict_40=get_min_distance_pos_from_newDGspan(newDGspan_filter_shuffled, matrix_PDB_distance, noBPlist_28S, 7924, 12994, winbin)

# plot scatter plot:
print(str(datetime.now())[:-7], "Plot shuffling shape_sharc scatter plot ...")
#fig, ax = plt.subplots(figsize=(2,5.5))
plot_heatmap(matrix_aver_distance_0to20, SHARC_pairwise_dict_0to20, 7924, 12994, max_value, 2)
plot_heatmap(matrix_aver_distance_20to40, SHARC_pairwise_dict_20to40, 7924, 12994, max_value, 4)
plot_heatmap(matrix_aver_distance_40, SHARC_pairwise_dict_40, 7924, 12994, max_value, 6)
#plt.savefig(outprefix+'_shape_sharc_scatter.pdf')
#plt.close()
plt.show()